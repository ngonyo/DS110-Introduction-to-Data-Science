---
title: "Logistic Regression Model"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We are going to perform our first classification task. We are classifying a binary response using logistic regression. logistic regression is a well known "binary classifier". Logistic regression can classify only binary variables.

Let's use the logistic regression to classify a given passenger in the titanic as "survived" or "did not survive". Note that in the dataset "survived" is denoated by "1", and "0" for "did not survive"

```{r}
#set the working directory
setwd("C:/Users/Nathan/Desktop/DS110")
dir()

#read the titanic train and test datasets
TTrain=read.table("TitanicTrain.txt", sep="\t", header=T)
TTest=read.table("TitanicTest.txt", sep="\t", header=T)

head(TTrain)

summary(TTrain)

#Let's convert PClass and Sex into factor variables
TTrain$Sex=as.factor(TTrain$Sex)
TTrain$PClass=as.factor(TTrain$PClass)
TTrain$Survived=as.factor(TTrain$Survived)

summary(TTrain)

#We are ready to apply the logistic regression model
#WE will be using the function glm(), the same way we used lm() function to create multiple linear regression model with an extra item to denote the distribution family of the response variable(family=binomial)

LRSurvived=glm(Survived~PClass+Age+Sex,data=TTrain, family = binomial)
summary(LRSurvived)

Ex1=predict(LRSurvived, newdata=data.frame(PClass="2nd", Age=40, Sex= "male"),type="response")
Ex1

Ex2=predict(LRSurvived, newdata=data.frame(PClass="1st", Age=25, Sex= "female"),type="response")
Ex2

#Now we are using the TTest test dataset to check the prediction and then later on to check the prediction accuracy
#First convert factor variables in the test dataset
TTest$Sex=as.factor(TTest$Sex)
TTest$PClass=as.factor(TTest$PClass)
TTest$Survived=as.factor(TTest$Survived)

#Now we are ready to predict
LRSurvivalPrediction=predict(LRSurvived, newdata=data.frame(TTest[, 3:5]), type="response")
LRSurvivalPredictionRounded=round(LRSurvivalPrediction)
table(LRSurvivalPrediction)

#Lets first create the confision matrix of the actual vs predicted survival. note that we are going ot have the actual values in the left hand side (rows) and predicted on the top (columns). confmat refers to confusion matrix
print("==========Confusion Matrix=========")
ConfMat=table(Actual=TTest$Survived, Predicted=LRSurvivalPredictionRounded)
ConfMat[1,1]
ConfMat[1,2]
ConfMat[2,1]
ConfMat[2,2]

ConfMat[1,1]+ConfMat[1,2]+ConfMat[2,1]+ConfMat[2,2]
nrow(TTest)

Accuracy=(ConfMat[1,1]+ConfMat[2,2])*100/nrow(TTest)
print(paste("Prediction Accuracy = ", Accuracy))

print("=========FORMATTED OUTPUTS=========")

Accuracy=(ConfMat[1,1]+ConfMat[2,2])*100/nrow(TTest)
print(paste("Prediction Accuracy = ", round(Accuracy), 0, "%"))
      
Sensitivty=ConfMat[2,2]*100/(ConfMat[2,1]+ConfMat[2,2])
print(paste("Sensitivity = ", round(Sensitivty, 0), "%"))

Specificity=ConfMat[2,2]*100/(ConfMat[2,1]+ConfMat[2,2])
print(paste("Specificity = ", round(Sensitivty, 0), "%"))

FPR=100-Specificity
print(paste("False Positive Rate = ", round(FPR, 0), "%"))
            
###ROC CURVE###

#We are going to create the ROC curve for the logistedRegression model of the Titanic data
#ROC curve will tell you the comparison between the TPR (y-axis) and FRP (x-axis)
#To create the ROC curve we need to install the package "pROC" 
#Now let's load the package
require(pROC)

#Lets create hte ROC curve for the logistic regression predictions. Note that the roc() function takes numeric values. IF your classification model outputs other types of values other than numerics, please convert them into numeric. You will see this in k-Nearest Neighbor classification.

ROC.LR=roc(TTest$Survived, LRSurvivalPredictionRounded)
ROC.LR

```





```{r}

#Lets create some loops, if-else conditions, and functions in R.

#For Loops--------
#The syntax goes as for (i in start:end){your code to repeat}
#Lets create a loop to print 1-10
for(i in 1:10){
 print(i)
}

start=5
end=50
for(i in start:end){
  print(i)
}


#print numbers from 1 to 10 and at the end give the sum
sum=0
for(i in 1:9){
  print(i)
  sum=sum+i
}
print(paste("The Sum of 1 to 10 is ", sum))

#While Loops----------

#Let's write a while loop. this is useful when you don't know how many iterations / start and end points as needed in a for loop. while loops will run as long as a condition is satisfied

#lets print 1 to 10 as long as a <= 10
a=1
while(a<=10){
  print(a)
  a=a+1

}

```

 

\newpage

```{r}
#Functions---------
#Now lets use a function to print the numbers 1 to 10.
numPrint=function(a,b){
  for(i in a:b){
    print(i)
  }
}


numPrint(1,5)

 

#Let's modify our function slightly...

numPrint=function(a,b){

  sum=0

  for(i in a:b){

    print(i)

    sum=sum+i

  }

  print(paste("The sum of numbers between ", a, " and ", b, "is ",sum))

}

numPrint(15,151)

 

```

 

\newpage

#If conditions

```{r}
#We are going to wrtie a simple if condition
 
#a) check if given number is zero
x=7
if(x==0){
  print("ZERO")
}
 
#Now lets add what to do for else case
x=7
 
if(x==0){
  print("ZERO")
}else{
  print("NOT A ZERO")
} 

 

 
#Now lets check whether a given number is a zero, negative, or positive
x=-7
if(x==0){
  print("ZERO")
}else
  if(x>0){
    print("POSITIVE")
  }else
  if(x<0){
    print("NEGATIVE")
  }

is.numeric(x) 

#Recursive functions: these functions call themsevles within the function.

 

#For an example, lets create a function to compute the factorial of a number.

#factorial of 3=3x2x1

 

#How we write this is if the function name is calFact()

#To compute factorial of 5, 5*calfact(4) and calfact(3) until it gets to 0 where it will return 0
calFact=function(a){
  if(is.numeric(a)==FALSE){
    print("enter a integer")
  }else
  if(a<0){
    print("enter a non negative number")
  }else{
    if(a==0){
      return(1)
    }else{a*calFact(a-1)}
  }
}
calFact(5)
calFact(a)

```

Your task: Read the Titanic Train Dataset and create ggplot2 plots each PClass in the dataset, using loops.

.1 How to find n

```{r}
setwd("C:/Users/Nathan/Desktop/DS110")

#read the titanic train and test datasets
TTrain=read.table("TitanicTrain.txt", sep="\t", header=T)
TTest=read.table("TitanicTest.txt", sep="\t", header=T)

TTrain$Sex=as.factor(TTrain$Sex)
TTrain$PClass=as.factor(TTrain$PClass)
TTrain$Survived=as.factor(TTrain$Survived)

summary(TTrain)

require(ggplot2)

#function levels will get you different levels in a factor variable
lvls=levels(TTrain$PClass)
#This vies the length of the array of levels in the PClass
n=length(lvls)
n

for(i in 1:n){
  #subset the dataset for each PClass
  sub=subset(TTrain, PClass==lvls[i])
  subname=paste("TTrain-", lvls[i], "Class.txt")
  write.table(sub, subname, sep="\t", row.names=FALSE)
  
  #create the plots for each PClass
  ggplot(sub, aes(x=Age))+geom_histogram()
  svname=paste("AgeHistogram", lvls[i], "Class.png")
  ggsave(svname)
}  
  
slvsl=levels(TTrain$Survived)
for(i in 1:n){
  #subset the dataset for each PClass
  sub=subset(TTrain, PClass==lvls[i])
  subname=paste("TTrain-", lvls[i], "Class.txt")
  write.table(sub, subname, sep="\t", row.names=FALSE)
  
  #create the plots for each PClass
  ggplot(sub, aes(x=Age))+geom_histogram()
  svname=paste("AgeHistogram", lvls[i], "Class.png")
  ggsave(svname)
}




```